---
import { Image } from 'astro:assets';
import type { ImageMetadata } from 'astro';
import { imagePresets, defaultPreset } from '../../lib/image-presets';

export interface Props {
  src: ImageMetadata | string;
  alt?: string;
  width?: number;
  height?: number;
  class?: string;
  preset?: keyof typeof imagePresets;
  sizes?: string;
  loading?: 'eager' | 'lazy';
  decoding?: 'auto' | 'sync' | 'async';
  fetchpriority?: 'high' | 'low' | 'auto';
  /** Enable picture element with srcset for static images (default: true) */
  usePicture?: boolean;
}

const {
  src,
  alt = '',
  width,
  height,
  class: className = '',
  preset,
  sizes,
  loading = 'lazy',
  decoding = 'async',
  fetchpriority = 'auto',
  usePicture = true,
} = Astro.props;

const selectedPreset = preset ? imagePresets[preset] : defaultPreset;
const computedSizes = sizes ?? selectedPreset.sizes;

// Check if src is an imported image (ImageMetadata) or static path (string)
const isImportedImage = typeof src === 'object' && 'src' in src;

// Helper function to generate srcset for static images
function generateSrcSet(basePath: string, widths: number[], format: 'webp' | 'avif'): string {
  return widths
    .map((w) => `${basePath}-${w}w.${format} ${w}w`)
    .join(', ');
}

// Extract base path and check for optimized variants
function getOptimizedImagePaths(staticPath: string, widths: number[]) {
  // Remove leading slash and extract base name
  const basePath = staticPath.replace(/^\//, '').replace(/\.(png|jpg|jpeg|webp|avif)$/i, '');
  const fullBasePath = `/${basePath}`;
  
  // Use the widths directly from preset (now aligned with actual optimized image widths)
  return {
    avifSrcSet: generateSrcSet(fullBasePath, widths, 'avif'),
    webpSrcSet: generateSrcSet(fullBasePath, widths, 'webp'),
    fallbackSrc: staticPath, // Keep original as fallback
    basePath: fullBasePath,
  };
}
---

{isImportedImage ? (
  // Use Astro's Image component for imported images
  <Image
    src={src as ImageMetadata}
    alt={alt}
    widths={selectedPreset.widths}
    sizes={computedSizes}
    format="webp"
    class={className}
    loading={loading}
    decoding={decoding}
    fetchpriority={fetchpriority}
    {...(width ? { width } : {})}
    {...(height ? { height } : {})}
  />
) : usePicture ? (
  // Use picture element with srcset for optimized static images
  (() => {
    const staticPath = src as string;
    const paths = getOptimizedImagePaths(staticPath, selectedPreset.widths);
    return (
      <picture>
        <source
          type="image/avif"
          srcset={paths.avifSrcSet}
          sizes={computedSizes}
        />
        <source
          type="image/webp"
          srcset={paths.webpSrcSet}
          sizes={computedSizes}
        />
        <img
          src={paths.fallbackSrc}
          alt={alt}
          width={width}
          height={height}
          class={className}
          loading={loading}
          decoding={decoding}
          fetchpriority={fetchpriority}
        />
      </picture>
    );
  })()
) : (
  // Use regular img tag for static paths (fallback)
  <img
    src={src as string}
    alt={alt}
    width={width}
    height={height}
    class={className}
    sizes={computedSizes}
    loading={loading}
    decoding={decoding}
    fetchpriority={fetchpriority}
  />
)}


